1 МЕТА РОБОТИ

Метою лабораторної роботи є розробка серверної частини програмної системи, включаючи реалізацію бізнес-логіки, створення бази даних та реалізацію кінцевих точок API. Завдання включають створення програмного коду, який відповідає вимогам бізнес-процесу, та написання звіту, в якому детально описані інженерні рішення з посиланнями на використаний програмний код.

2 КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ

Для ефективної розробки серверної частини важливо детально описати всі необхідні елементи для реалізації певного функціоналу. Для цього можна створити ER-модель даних, яка дозволить представити всі основні сутності та позначити зв’язки, які можуть встановлюватись між створеними сутностями. Після визначення всіх необхідних компонентів була розроблена відповідна ER-модель даних (див. рис. Б.1 у додатку Б).
Модель даних охоплює наступні компоненти та відповідні атрибути для них:
а) користувач, який має наступні поля: користувач_id, ім’я, прізвище, по_батькові, пароль, електронна_пошта, номер_телефон, ролі.
б) контейнер, який має наступні поля: тип, назва, вантажопідйомність, довжина, ширина, висота, поїздка_id, статус.
в) токен_оновлння, який має наступні поля: токен_id, токен, дата_кінця.
г) роль, яка має наступні поля:  роль_id, назва.
д) водій, який має наступні поля: водій_id, ім’я, прізвище, по_батькові, пароль, електронна_пошта, номер_телефон, номер_водійського_посвідчення.
к) вантаж, який має наступні поля: вантаж_id, назва, вага, оголошена вартість, довжина, ширина, висота, ціна доставки, відомість_id, місто_відправки_id, адрес_відправки, місто_отримання_id, адрес_отримання.
л) місто, яке має наступні поля: місто_id, назва_міста, район, країна.
м) датчики, який має наступні поля: контейнер_id, датчик_id.
н) значення, яке має наступні поля: значення_id, датчик_id, значення, час_вимірювання.
п) датчик, який має наступні поля: датчик_id, тип, назва.
р) розклад, який має наступні поля: розклад_id, подорож_id, місто_id, час прибуття.
с) подорож, яка має наступні поля: подорож_id, машина_id, водій_id.
т) машина, яка має наступні поля: машина_id, номер машини, бренд, вантажопідйомність.
у) відомість, яка має наступні поля: відомість_id, подорож_id, контейнер_id.
Кожна сутність має визначені поля для ефективної реалізації передбаченого функціоналу системи.
Після визначення всіх сутностей, наступним кроком є формування ключових сценаріїв використання програмної системи . Для досягнення цієї мети ідеально використовувати UML-діаграму прецедентів. Після ретельного аналізу функціоналу, який був визначений у документі "Vision & Scope", було розроблено UML-діаграму прецедентів (див. рис. Б.2 у додатку Б). У визначеній UML-діаграмі прецедентів присутні п'ять акторів: гість, користувач, логіст, адміністратор та датчик. Кожен із цих акторів має доступ до раніше визначеного функціоналу. 
Зокрема, користувач може вносити зміни до своєї особистої інформації, переглядати інформацію про доставку, створення замовлення на перевезення вантажу згідно необхідних характеристик, зокрема переглядати місцезнаходження вантажу та історію його перевезення.
Гість має можливість зареєструватись, або авторизуватись у системі, але при цьому, він може тільки переглядати тарифи та інформацію про вантажоперевезення.
Логіст має можливість додавати, редагувати та видаляти інформацію про подорож, та розклад, знаходження найближчого контейнера. Також він має змогу формувати статистику по кількості перевезеного вантажу та вагу перевезеного вантажу. Логіст має доступ до загального функціоналу, який наявний у користувача.
Адміністратор має можливість внесення змін до будь-яких даних у базі даних та отримання необхідної інформації. Він має доступ до функціоналу, який доступний власнику та користувачу.
Останнім актором є датчик, який має можливість змінювати поточного місця перебування, зміна статусу відкриття контейнера та зміна поточної температури.
Після завершення концептуального моделювання предметної області було розроблено дві діаграми та визначено основні сутності програмної системи. З цього етапу можна переходити до реалізації інженерних рішень.

3 ІНЖЕНЕРНІ РІШЕННЯ
3.1 Структура проєкту

Вибір технологій для розробки серверної частини був обґрунтований функціональними вимогами системи та досвідом в розробці минулих проєктів. Таким чином, для написання серверної частини була вибрана платформа .NET 7. REST-орієнтована специфікація використовує архітектурний стиль, що акцентує на використанні ресурсів та їхньому ідентифікуванні через URI. В проєкті ASP.NET Core контролери використовуються для створення RESTful веб-сервісів, які взаємодіють відповідно до принципів REST.
Як база даних використовується документно-орієнтована MongoDB, оскільки вона надає гнучкість та ефективність для роботи з документами у форматі JSON-подібних об'єктів. MongoDB легко масштабується та забезпечує швидкий доступ до даних, а взаємодія з базою даних реалізована за допомогою Mongo Driver.
Комунікація між сервером та клієнтською частиною здійснюється за допомогою REST API, що використовується як для мобільного додатку, так і для IoT. Деталі взаємодії серверної частини з іншими компонентами системи можна розглянути на UML-діаграмі розгортання (див. рис. 3).
Отримання даних від IoT також буде реалізоване за допомогою REST API. Тому для  покращення розуміння взаємодії між IoT та серверною частиною була створена UML діаграма діяльності, адже вона представляє потоки робочого процесу або операцій в системі. Вона відображає послідовність кроків та контрольну структуру, які описують, як діяльності виконуються для досягнення певної мети (див.рис.4). Алгоритм має циклічний характер, тому розпочинається очікуванням протягом 20 секунд. Далі відбувається вимірювання поточних координат та температури, додатково відбувається перевірка на відкриття контейнера  за допомогою датчику, і результат відправляється POST-запитом до серверної частини.
Після отримання запиту серверною частиною  відбувається запис значень в базу даних. За допомогою даного алгоритму можна досягти максимальної якості отримання значень в реальному часі.
Додаток використовує чисту архітектуру (див. рис. 5). Унікальність цієї архітектури полягає в тому, як код організовано, щоб забезпечити низьку взаємозалежність компонентів, легкість тестування та модифікації. 
Ця архітектура дотримується принципів SOLID та централізує бізнес-логіку, відокремлюючи її від інтерфейсу користувача, бази даних та зовнішніх агентів. Даний додаток складається з 5 шарів.
Domain для зберігання сутностей переліків, всі інші шари використовують цей шар. Application має інтерфейси і DTO (Об'єкти передачі даних). 
Далі Persistence відповідає за доступ до бази даних і має реалізацію репозиторіїв. 
Шар Infrastructure відповідає за реалізацію сервісів. І останній, Api шар має контролери, що реалізують REST API інтерфейс.

3.2 Специфікація REST API 
		
Специфікація REST API наведена в таблиці 1 нижче.
Таблиця 1 – Специфікація REST API серверної частини системи
Сутність	Метод	Посилання	Дія
Користувач	
GET	/users/all	Повернення список користувачів
/users/{id}	Повернення користувача за ідентифікатором
POST	/users/register	Реєстрація користувача
/users/login	Вхід у систему
/users/{id}/roles{roleName}	Додавання ролі користувачу
PUT	/users/update	Оновлення даних користувача
DELETE /users/{id}/roles{roleName}	Видалення ролі користувача
/users/{id}	Видалення користувача
Контейнер	
GET	/container/all	Повернення всіх наявні контейнерів
/container/find/{coordinates}	Повернення найближчих контейнерів, за координатами
/container/{id}	Повернення контейнера за його ідентифікатором
POST /container /create	Створення контейнера
Продовження таблиці 1
Сутність	Метод	Посилання	Дія
Контейнер	
PUT	/container/update	Оновлення даних про контейнер
/container/updateTrip	Оновлення подорожі для контейнера
DELETE	/ container /delete/{id}	Видалення контейнера
Вантаж	
GET	/cargo/sender/{id}	Повернення всіх вантажів відправника
/cargo/receiver/{id}	Повернення всіх вантажів отримувача
/cargo/{id}	Повернення інформації про вантаж
POST	/cargo/create	Створення вантажу
PUT	/cargo/update	Оновлення даних про вантаж
/cargo/update/container{id}	Оновлення номера контейнера  
DELETE	/ cargo /delete/{id}	Видалення вантажу
Місто	
GET	/city/{id}	Повернення міста за його ідентифікатором
POST	/city/create	Cтворення міста
PUT	/city/update	Оновлення даних про налаштування
DELETE	/city/delete/{id}	Видалення налаштування
Продовження таблиці 1
Сутність	Метод	Посилання	Дія
Розклад	
GET	/schedule/{id}	Повернення розкладу за його ідентифікатором
/schedule/trip/{id}	Повернення розкладу за ідентифікатором подорожі
POST	/schedule/create	Створення розкладу
PUT	/schedule/update	Редагування даних розкладу
DELETE	/schedule/delete/{id}	Видалення розкладу
Датчик	
GET	/sensor/all	Повернення всіх датчиків
/sensor/{type}	Повернення датчиків за типом
POST	/sensor/create	Створення датчика
PUT	/sensor/update	Оновлення даних про датчик
DELETE	/sensor/delete/{id}	Видалення датчику
Значення	
GET	/value/sensor/{id}	Повернення значення за ідентифікатором датчика
/value/sensor/{type}/ container/{id}	Повернення значення за типом датчика та за окремим контейнером
POST	/value/create	Створення значення
PUT	/value/update	Оновлення значення
DELETE	/ value /delete/{id}	Видалення значення
Продовження таблиці 1
Сутність	Метод	Посилання	Дія
Датчики	
GET	/sensors	Повернення всі датчиків
/sensors/container/{id}	Повернення всіх датчики для окремого контейнера
/sensors/{type}/container/{id}	Повернення окремого датчики для окремого контейнера за типом датчика
/sensors/{id}/container/{id}	Повернення окремого датчики для окремого контейнера
POST	/sensors/create	Створення датчиків для контейнера
PUT	/sensors/update	Оновлення датчиків для контейнера 
DELETE	/sensors/delete/{id}	Видалення датчиків
Водій	
GET	/driver/{id}	Повернення користувача за ідентифікатором
POST	/driver/create	Створення водія
PUT	/driver/update	Оновлення даних водія
DELETE	/driver/{id}	Видалення водія
Подорож	
GET	/trip/{id}	Повернення подорожі
POST	/trip/create	Створення подорожі
PUT	/trip/update	Оновлення даних подорожі
DELETE	/trip/{id}	Видалення подорожі
Кінець таблиці 1
Сутність	Метод	Посилання	Дія
Машина	
GET	/car/{id}	Повернення машини за його ідентифікатором
POST	/car/create	Створення машини
PUT	/car/update	Редагування даних машини
DELETE	/car/delete/{id}	Видалення машини
Відомість	
GET	/notice/{id}	Повернення відомості за його ідентифікатором
POST	/notice/create	Створення відомості
PUT	/notice/update	Редагування даних відомості
DELETE	/notice/delete/{id}	Видалення відомості
Статистика	
GET/statistics/delivery/сontainer	Повертає назву контейнера,  тип,  кількість подорожей, середня завантаженість, середній об’єм вантажу
/statistics/trip{id}	Повертає загальний витрачений час, назву контейнера, тип, загальна вага, середня швидкість

3.3 Реалізація методу обробки даних для пошуку найближчого контейнера за координатами

При переході до конкретних реалізацій, було прийнято рішення розпочати з методу, що відповідає за ключовий функціонал системи – пошук найближчого контейнера за координатами. Основною задачею цього методу є прийом параметрів, метод приймає необхідні параметри для пошуку контейнера, а саме  координату довжини та координату ширини(див. рядок 3-18, розділ А.1 у додатку А). Далі відбувається автоматичне знаходження необхідного датчику і зчитування останні значення (див. рядок 5, розділ А.1 у додатку А). В результаті методу буде повернуто інформацію про контейнер, його координати, та відстань від місця пошуку.

3.4 Реалізація методів для статистики

Програмна система вкладає значну увагу в обробку статистичних даних, які становлять невід’ємну частину бізнес-логіки. Розглянемо статистику подорожі, а саме витрачений час, назву контейнера, його тип, загальна вага вантажа, середня швидкість руху 
Спочатку отримуються контейнер, який використовувався для перевезення (див. рядок 3-6, розділ А.2 у додатку А). Далі для  контейнера визначаємо назву, його тип (див. рядок 7-13, розділ А.2 у додатку А). Далі за допомогою запити дізнаємось загальну вагу вантажу, який був завантажений в даний контейнер, потім дізнаємось координати з початкового місця та місця прибуття (див. рядок 15-25, розділ А.2 у додатку А). Далі визначаємо відстань між даними місцями і ділимо на кількість часу, який був витрачений у даній подорожі. У кінці метод повертає статистику подорожі. Через те, що код зосереджений на отриманні та обробці даних щодо аналізу подорожі, його можна вважати частиною бізнес-логіки. Бізнес-логіка в даному випадку полягає в аналізі швидкості руху, кількості завантаженого вантажу та представленні статистики подорожі для прийняття рішень або отримання інформації.
Наступною статистикою є отримання інформації про контейнери, а саме перегляд його назви, тип, кількість подорожей, середня завантаженість, середній об’єм вантажу. Спочатку отримуємо інформацію про історію перевезення для заданого контейнера (див. рядок 3, розділ А.3 у додатку А). Далі для кожного контейнера визначаємо середню вагу та об’єм (див. рядок 7-58, розділ А.3 у додатку А). У кінці метод повертає сформований список статистики контейнера. Через те, що код зосереджений на отриманні та обробці даних щодо аналізу контейнерів, його теж  можна вважати частиною бізнес-логіки. Бізнес-логіка в даному випадку полягає в аналізі використання контейнерів для прийняття рішень та покращенням в майбутньому процесу перевезення. 

3.5 Перевірка даних на коректність введення.

Гарантування точності та достовірності вхідних даних є критичним завданням для забезпечення належного функціонування програмного забезпечення. Якщо введені користувачем дані не відповідають встановленим критеріям, це може призвести до виникнення винятків або помилок. Такі виключні ситуації мають бути належним чином оброблені програмним кодом, щоб забезпечити відповідну реакцію та запобігти некоректній поведінці системи. Наведений нижче фрагмент коду демонструє приклад реалізації процесу валідації вхідних даних:
private async void ValidateEmail(string email)
    {
        string regex = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";

        if (!Regex.IsMatch(email, regex))
        {
            throw new InvalidEmailException(email);
        }
    }

3.6 Резервне копіювання користувацьких даних.

Резервне копіювання стало життєво важливою практикою, адже постійно відбувається використання цифрової інформації. Непередбачувані події, такі як збій жорсткого диска, програмний збій, викрадення даних або людська помилка, можуть призвести до втрати даних. Тому було використано популярну бібліотеку CsvHelper і розроблено  метод ExportCsv, де відбувається зчитування інформації з колекції, після чого йде запис у файл з розширенням csv (див. рядок 3, розділ А.3 у додатку А).

4 ВИСНОВКИ

В результаті виконання лабораторної роботи, була успішно розроблено та протестована серверна частина програмної системи. Для кращого розуміння предметної області та архітектури системи були розроблені відповідні діаграми. Також була створена демонстраційна відео-презентація, в якій висвітлені основні функції системи. Ви можете переглянути цей відеоролик за наступним посиланням: (DEMO: https://youtu.be/GfMBKuVBgxs)
